#include <condition_variable>
#include <iostream>
#include <queue>
#include <thread>

// Define event identifiers
enum event_identifier { EVENT_TIMER_1 = 1, EVENT_TIMER_2 };

// Entry point
auto main() -> int {

  // Timing parameters
  const uint32_t TIMER_1_INVERVAL_MS = 1000;
  const uint32_t TIMER_2_INVERVAL_MS = 2000;
  const uint32_t EXECUTION_TIME_MS = 10000;

  // Declare shared variables between threads
  std::queue<event_identifier> event_queue;
  std::condition_variable condition;
  std::mutex event_mutex;
  bool stop = false;

  // Emulates a timer that send events
  auto timer = [&](event_identifier ev_id, uint32_t interval_ms) {
    while (!stop) {
      std::this_thread::sleep_for(std::chrono::milliseconds(interval_ms));

      // Lock while pushing the event
      std::unique_lock<std::mutex> lock(event_mutex);
      event_queue.push(ev_id);
      condition.notify_one();
    }
  };

  // Handle the event generated by timers
  auto event_loop = [&]() {
    std::unique_lock<std::mutex> lock(event_mutex);
    while (!stop) {
      if (event_queue.empty()) {
        condition.wait(lock);
      } else {
        event_identifier ev_id = event_queue.front();
        event_queue.pop();
        std::cout << "Event " << ev_id << ": t = "
                  << std::chrono::duration_cast<std::chrono::milliseconds>(
                         std::chrono::steady_clock::now().time_since_epoch())
                         .count()
                  << "ms\n";
      }
    }
  };

  // Start event loop then two timers, wait ten seconds and quit
  std::thread event_thread(event_loop);
  std::thread timer_1(timer, EVENT_TIMER_1, TIMER_1_INVERVAL_MS);
  std::thread timer_2(timer, EVENT_TIMER_2, TIMER_2_INVERVAL_MS);
  std::this_thread::sleep_for(std::chrono::milliseconds(EXECUTION_TIME_MS));
  stop = true;
  timer_2.join();
  timer_1.join();
  event_thread.join();

  return EXIT_SUCCESS;
}
